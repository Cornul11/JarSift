package nl.tudelft.cornul11.thesis.corpus.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import nl.tudelft.cornul11.thesis.corpus.database.MongoDbClient;
import nl.tudelft.cornul11.thesis.corpus.util.ConfigurationLoader;
import org.bson.Document;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.*;
import java.util.stream.Collectors;

public class VulnerabilityAnalyzer {
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityAnalyzer.class);
    private static final double DEFAULT_THRESHOLD = 0.8;
    private final double threshold;
    private final MongoDbClient mongoDbClient;
    private final int totalClassFileCount;

    public VulnerabilityAnalyzer(int totalClassFileCount, ConfigurationLoader config, Double threshold) {
        this.totalClassFileCount = totalClassFileCount;
        this.mongoDbClient = new MongoDbClient(config);
        this.threshold = Objects.requireNonNullElse(threshold, DEFAULT_THRESHOLD);
    }

    public void checkForVulnerability(Map<String, Map<String, Object>> libraryVersionMap, String filePath) {
        List<LibraryVersion> libraryVersions = new ArrayList<>();
        for (Map.Entry<String, Map<String, Object>> entry : libraryVersionMap.entrySet()) {
            double ratio = (double) entry.getValue().get("ratio");

            if (ratio >= threshold) { // TODO: make this a parameter, or make it configurable;
                LibraryVersion libraryVersion = getLibraryVersion(entry);
                libraryVersions.add(libraryVersion);
            }
        }

        // Sort in decreasing order of count
        libraryVersions.sort((lib1, lib2) -> Long.compare(lib2.getCount(), lib1.getCount()));

        // Log results
        for (LibraryVersion libraryVersion : libraryVersions) {
            ArrayList<Document> vulnerabilitiesList = mongoDbClient.getVulnerabilities(libraryVersion.getLibrary(), libraryVersion.getVersion());

            List<String> vulnerabilityIds = vulnerabilitiesList.stream()
                    .map(doc -> doc.getString("id"))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
            libraryVersion.setVulnerabilities(vulnerabilityIds);
            logResult(libraryVersion, vulnerabilitiesList);
        }

        if (filePath != null) {
            writeAnalysisToJsonFile(libraryVersions, filePath);
        }

        if (libraryVersions.isEmpty()) {
            logger.info("No matches or vulnerabilities found");
        }
    }

    private LibraryVersion getLibraryVersion(Map.Entry<String, Map<String, Object>> entry) {
        String[] parts = entry.getKey().split(":");
        String library = parts[0] + ":" + parts[1];
        String version = parts[2];
        long count = (long) entry.getValue().get("count");
        long total = (long) entry.getValue().get("total");
        double ratio = (double) entry.getValue().get("ratio");

        return new LibraryVersion(library, version, count, total, ratio);
    }

    private void logResult(LibraryVersion libraryVersion, ArrayList<Document> vulnerabilities) {
        DecimalFormat decimalFormat = new DecimalFormat("#.##");
        double libraryPercentage = libraryVersion.getRatio() * 100;
        double overallPercentage = (libraryVersion.getCount() * 100.0) / totalClassFileCount;
        String libraryPercentageString = decimalFormat.format(libraryPercentage);
        String overallPercentageString = decimalFormat.format(overallPercentage);

        StringBuilder status;
        if (vulnerabilities.isEmpty()) {
            status = new StringBuilder("✅");
        } else {
            status = new StringBuilder("❌");
            try {
                for (Document doc : vulnerabilities) {
                    Object aliasesField = doc.get("aliases");
                    if (aliasesField == null) {
                        status.append(" -> ").append(doc.get("id"));
                    } else if (aliasesField instanceof List && !((List<?>) aliasesField).isEmpty()) {
                        List<?> aliases = (List<?>) aliasesField;
                        Object firstAlias = aliases.get(0);
                        status.append(" -> ").append((String) firstAlias);
                    }
                }
            } catch (Exception e) {
                logger.error("Error while processing library version: " + libraryVersion.getVersion(), e);
            }
        }

        String output = String.format("Library-Version: %s:%s, Count: %d / %d (Library ratio: %s%%, Overall ratio: %s%%) %s",
                libraryVersion.getLibrary(), libraryVersion.getVersion(), libraryVersion.getCount(), libraryVersion.getTotal(), libraryPercentageString, overallPercentageString, status);

        logger.info(output);
    }

    public void writeAnalysisToJsonFile(List<LibraryVersion> libraryVersions, String filePath) {
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            objectMapper.writeValue(new File(filePath), libraryVersions);
        } catch (IOException e) {
            logger.error("Error while writing analysis to JSON file", e);
        }
    }

    public static class LibraryVersion {
        private final String library;
        private final String version;
        private final long count;
        private final long total;
        private final double ratio;
        private List<String> vulnerabilities;

        public LibraryVersion(String library, String version, long count, long total, double ratio) {
            this.library = library;
            this.version = version;
            this.count = count;
            this.total = total;
            this.ratio = ratio;
            this.vulnerabilities = new ArrayList<>();
        }

        public void setVulnerabilities(List<String> vulnerabilities) {
            this.vulnerabilities = vulnerabilities;
        }

        public List<String> getVulnerabilities() {
            return vulnerabilities;
        }

        public String getLibrary() {
            return library;
        }

        public String getVersion() {
            return version;
        }

        public long getCount() {
            return count;
        }

        public long getTotal() {
            return total;
        }

        public double getRatio() {
            return ratio;
        }
    }
}