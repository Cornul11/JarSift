package nl.tudelft.cornul11.thesis.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import nl.tudelft.cornul11.thesis.api.ApiResponse;
import nl.tudelft.cornul11.thesis.api.PostRequestClient;
import nl.tudelft.cornul11.thesis.api.Schema;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.text.DecimalFormat;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class VulnerabilityAnalyzer {
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityAnalyzer.class);
    private final PostRequestClient postRequestClient;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public VulnerabilityAnalyzer(PostRequestClient postRequestClient) {
        this.postRequestClient = postRequestClient;
    }

    public void checkForVulnerability(Map<String, Map<String, Long>> libraryVersionMap, int classFileCount) {
        for (Map.Entry<String, Map<String, Long>> entry : libraryVersionMap.entrySet()) {
            try {
                LibraryVersion libraryVersion = getMaxLibraryVersion(entry);
                processLibraryVersion(libraryVersion, classFileCount);
            } catch (IOException e) {
                logger.error("Error during processing: " + e.getMessage());
            }
        }
    }

    private LibraryVersion getMaxLibraryVersion(Map.Entry<String, Map<String, Long>> entry) {
        String library = entry.getKey();
        String maxVersion = Collections.max(entry.getValue().entrySet(), Map.Entry.comparingByValue()).getKey();
        long maxCount = entry.getValue().get(maxVersion);

        return new LibraryVersion(library, maxVersion, maxCount);
    }

    private void processLibraryVersion(LibraryVersion libraryVersion, int classFileCount) throws IOException {
        ObjectMapper objectMapper = new ObjectMapper();

        // prepare the JSON data
        Map<String, Object> data = new HashMap<>();
        data.put("version", libraryVersion.getVersion());
        data.put("package", Map.of("name", libraryVersion.getLibrary(), "ecosystem", "Maven"));

        String response = postRequestToApi(objectMapper, data);
        ApiResponse responseObject = objectMapper.readValue(response, ApiResponse.class);

        logResult(libraryVersion, responseObject, classFileCount);
    }

    private String postRequestToApi(ObjectMapper objectMapper, Map<String, Object> data) throws IOException {
        String jsonData = objectMapper.writeValueAsString(data);
        String url = "https://api.osv.dev/v1/query";
        return postRequestClient.makePostRequest(url, jsonData);
    }


    private void logResult(LibraryVersion libraryVersion, ApiResponse responseObject, int classFileCount) {
        DecimalFormat decimalFormat = new DecimalFormat("#.##");
        double percentage = (libraryVersion.getCount() * 100.0) / classFileCount;
        String percentageString = decimalFormat.format(percentage);

        StringBuilder status;
        if (responseObject.getVulns() == null) {
            status = new StringBuilder("✅");
        } else {
            status = new StringBuilder("❌");
            for (Schema schema : responseObject.getVulns()) {
                status.append(" -> ").append(schema.getAliases().get(0));
            }
        }

        String output = String.format("Library-Version: %s-%s, Count: %d / %d (%s%%) %s",
                libraryVersion.getLibrary(), libraryVersion.getVersion(), libraryVersion.getCount(), classFileCount, percentageString, status.toString());

        logger.info(output);
    }

    class LibraryVersion {
        private final String library;
        private final String version;
        private final long count;

        public LibraryVersion(String library, String version, long count) {
            this.library = library;
            this.version = version;
            this.count = count;
        }

        public String getLibrary() {
            return library;
        }

        public String getVersion() {
            return version;
        }

        public long getCount() {
            return count;
        }
    }
}